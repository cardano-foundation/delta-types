<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.Store</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">delta-store-1.0.0.0: Facilities for storing a Haskell value, using delta types.</span><ul class="links" id="page-menu"><li><a href="src/Data.Store.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>&#169; 2022-2023 IOHK 2023-2025 Cardano Foundation</td></tr><tr><th>License</th><td>Apache-2.0</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Data.Store</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Store, definition</a><ul><li><a href="#g:2">Type</a></li><li><a href="#g:3">Properties</a><ul><li><a href="#g:4">Laws: Load and Write</a></li><li><a href="#g:5">Laws: Update</a></li><li><a href="#g:6">Laws: Query</a></li><li><a href="#g:7">Monad</a></li><li><a href="#g:8">updateS, Maybe argument</a></li><li><a href="#g:9">loadS, SomeException</a></li></ul></li></ul></li><li><a href="#g:10">Store, functions</a><ul><li><a href="#g:11">Query</a></li><li><a href="#g:12">Constructors</a></li><li><a href="#g:13">Combinators</a></li><li><a href="#g:14">Helpers</a></li><li><a href="#g:15">Testing</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> represents a facility for storing one value of a given type.
Typically, this type is a collection type,
for example <code><a href="https://hackage.haskell.org/package/containers-0.7/docs/Data-Map.html#v:Map" title="Data.Map">Map</a></code><code> </code><code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></code><code> </code><code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code>,
so that we actually stores multiple values.</p><p>The key benefit of a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> is that it can store the value
<strong>outside of volatile memory (RAM)</strong> &#8212;
for example, the value can be stored in a database file on disk,
that is on persistent storage.</p><ul><li>Read-access is done on parts of the value, through a query GADT
  that is an instance of the <code><a href="Data-Store.html#t:Query" title="Data.Store">Query</a></code> class.
  In this way, we do not need to load the stored value
  fully into volatile memory.</li><li>Updates are incremental and use delta types, see <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta.html">Data.Delta</a>.
  In this way, we can modify the persistent storage incrementally.</li></ul><p>Conversely, there is no need to use <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> if
the value only ever lives in volatile memory
&#8212; in this case, it is much simpler to use a plain Haskell value,
introduced with <code>let</code>, <code>where</code>, or as a function argument.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Store">Store</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da = <a href="#v:Store">Store</a> {<ul class="subs"><li><a href="#v:loadS">loadS</a> :: m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da))</li><li><a href="#v:writeS">writeS</a> :: <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da -&gt; m ()</li><li><a href="#v:updateS">updateS</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da) -&gt; da -&gt; m ()</li><li><a href="#v:queryS">queryS</a> :: <span class="keyword">forall</span> b. qa b -&gt; m b</li></ul>}</li><li class="src short"><span class="keyword">class</span> <a href="#t:Query">Query</a> (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:World">World</a> (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>)</li><li><a href="#v:query">query</a> :: qa b -&gt; <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa -&gt; b</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Whole">Whole</a> a b <span class="keyword">where</span><ul class="subs"><li><a href="#v:Whole">Whole</a> :: <span class="keyword">forall</span> a. <a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a a</li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:SimpleStore">SimpleStore</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a = <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Replace" title="Data.Delta.Core">Replace</a> a)</li><li class="src short"><a href="#v:mkSimpleStore">mkSimpleStore</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m) =&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> a) -&gt; (a -&gt; m ()) -&gt; <a href="Data-Store.html#t:SimpleStore" title="Data.Store">SimpleStore</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:UpdateStore">UpdateStore</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da = <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da)) da</li><li class="src short"><a href="#v:mkUpdateStore">mkUpdateStore</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, a <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da) =&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> a) -&gt; (a -&gt; m ()) -&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a -&gt; da -&gt; m ()) -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da</li><li class="src short"><a href="#v:mkQueryStore">mkQueryStore</a> :: <span class="keyword">forall</span> m qa da. (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da, <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> qa, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa) =&gt; (<span class="keyword">forall</span> b. qa b -&gt; m b) -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da</li><li class="src short"><a href="#v:hoistStore">hoistStore</a> :: <span class="keyword">forall</span> m n (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> a. m a -&gt; n a) -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> n qa da</li><li class="src short"><a href="#v:embedStore">embedStore</a> :: (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadSTM-Internal.html#t:MonadSTM" title="Control.Monad.Class.MonadSTM.Internal">MonadSTM</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadMask" title="Control.Monad.Class.MonadThrow">MonadMask</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da) =&gt; <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding" title="Data.Delta.Embedding">Embedding</a> da db -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m db -&gt; m (<a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da)</li><li class="src short"><a href="#v:pairStores">pairStores</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da (qb :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) db. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qb db -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m (qa <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/GHC-Generics.html#t::-43-:" title="GHC.Generics">:+:</a> qb) (da, db)</li><li class="src short"><a href="#v:newCachedStore">newCachedStore</a> :: <span class="keyword">forall</span> m (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da. (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadSTM-Internal.html#t:MonadSTM" title="Control.Monad.Class.MonadSTM.Internal">MonadSTM</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadEvaluate" title="Control.Monad.Class.MonadThrow">MonadEvaluate</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da, <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> qa, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa) =&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; m (<a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da)</li><li class="src short"><a href="#v:updateLoad">updateLoad</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:Exception" title="Control.Exception">Exception</a> e, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e t) -&gt; (e -&gt; m b) -&gt; (t -&gt; da -&gt; m b) -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> t -&gt; da -&gt; m b</li><li class="src short"><a href="#v:loadWhenNothing">loadWhenNothing</a> :: <span class="keyword">forall</span> m da (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da) =&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da) -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; m (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da)</li><li class="src short"><a href="#v:embedStore-39-">embedStore'</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da db. (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m) =&gt; <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding-39-" title="Data.Delta.Embedding">Embedding'</a> da db -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m db -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da</li><li class="src short"><a href="#v:newStore">newStore</a> :: <span class="keyword">forall</span> m da (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadSTM-Internal.html#t:MonadSTM" title="Control.Monad.Class.MonadSTM.Internal">MonadSTM</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da, <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> qa, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa) =&gt; m (<a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da)</li><li class="src short"><span class="keyword">data</span> <a href="#t:NotInitialized">NotInitialized</a> = <a href="#v:NotInitialized">NotInitialized</a></li><li class="src short"><a href="#v:updateSequence">updateSequence</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> delta) =&gt; (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> delta -&gt; delta -&gt; m ()) -&gt; <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> delta -&gt; [delta] -&gt; m ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Store, definition</h1></a><a href="#g:2" id="g:2"><h2>Type</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Store" class="def">Store</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da <a href="src/Data.Store.html#Store" class="link">Source</a> <a href="#t:Store" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> is a storage facility for Haskell values of type
<code>a ~ </code><code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a></code><code> da ~ </code><code><a href="Data-Store.html#t:World" title="Data.Store">World</a></code><code> qa</code>.</p><p>Typical use cases are a file or a database on the hard disk.</p><p>The purpose of the type parameters is:</p><ul><li>The monad <code>m</code> encapsulates access to the storage space.</li><li>The query type <code>qa</code> represents the specialized queries
  that this store supports.</li><li>The delta type <code>da</code> is used for incremental updates.</li></ul><p>If you care about one these aspects, but not the others,
we recommend to use a specialized type synonym
such as <code><a href="Data-Store.html#t:SimpleStore" title="Data.Store">SimpleStore</a></code> or <code><a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Store" class="def">Store</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:loadS" class="def">loadS</a> :: m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da))</dfn><div class="doc"><p>Load the value from the store into memory, or fail.</p><p>This operation can be expensive.</p></div></li><li><dfn class="src"><a id="v:writeS" class="def">writeS</a> :: <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da -&gt; m ()</dfn><div class="doc"><p>Write a value from memory into the store.</p></div></li><li><dfn class="src"><a id="v:updateS" class="def">updateS</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da) -&gt; da -&gt; m ()</dfn><div class="doc"><p>Update the value in the store
 incrementally by using a <code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a></code> type <code>da</code>.</p><p>For effiency,
 the first argument may supply the current value in-memory.</p></div></li><li><dfn class="src"><a id="v:queryS" class="def">queryS</a> :: <span class="keyword">forall</span> b. qa b -&gt; m b</dfn><div class="doc"><p>Run a specialized <code><a href="Data-Store.html#t:Query" title="Data.Store">Query</a></code> on the value in the store.</p><p>This operation can be less expensive than <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code>,
 because the query may not need to load the whole value into memory.</p></div></li></ul></div></td></tr></table></div></div><a href="#g:3" id="g:3"><h2>Properties</h2></a><div class="doc"><p>Any implementation of <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> is expected to satisfy the <strong>properties</strong>
specified in this section.
We make no attempt at enforcing these properties on the type-level.
However, the module <a href="Test-Store.html">Test.Store</a> provides QuickCheck code for these
properties for automated testing.</p></div><a href="#g:4" id="g:4"><h3>Laws: Load and Write</h3></a><div class="doc"><p>The most fundamental operations on a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> are</p><ul><li><code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> &#8212; loads the value contained in the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> into memory.</li><li><code><a href="Data-Store.html#v:writeS" title="Data.Store">writeS</a></code> &#8212; writes a value from memory into the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>.</li></ul><p>These two operations are characterized by the following design:</p><ol><li value="1"><p>The store <strong>need not contain</strong> a properly formatted <strong>value</strong>.</p><p>Loading a value from the store may fail, and this is why <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code>
has an <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> result.
For example, if the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> represents
a file on disk, then the file may corrupted or in an incompatible
file format when first opened.
In such a case of failure, the result <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code><code> (e :: </code><code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a></code><code>)</code>
is returned, where the exception <code>e</code> gives more information
about the failure.</p><p>However, loading a value after writing it should always succeed,
we have</p><pre>writeS s a &gt;&gt; loadS s  =  pure (Right a)</pre></li><li value="2"><p>The store is <strong>redundant</strong>.</p><p>Two stores with different internal contents may contain
the same value of type <code>a</code>.
For example, two files with different whitespace
may describe the same JSON value.
In general, loading a value and writing it again may change the
internal store contents, i.e.</p><pre>loadS s &gt;&gt;= either (\_ -&gt; pure ()) (writeS s)  &#8800;  pure ()</pre></li></ol></div><a href="#g:5" id="g:5"><h3>Laws: Update</h3></a><div class="doc"><p>In order to update the store content without loading all of it into memory,
<code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> supports the operation</p><ul><li><code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code> &#8212; updates the value contained in the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> using a <code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a></code> type.</li></ul><p>This operation is characterized by the following law:</p><ul><li><p>Updating a store <strong>commutes with <code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#v:apply" title="Data.Delta.Core">apply</a></code></strong>.</p><p>We have</p><pre>updateS s (Just a) da &gt;&gt; loadS s  =  pure $ Right $ apply a da</pre><p>However, since the store is redundant, we often have</p><pre>updateS s (Just a) da  &#8800;  writeS s (apply a da)</pre></li></ul><p>The combination of <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code>, <code><a href="Data-Store.html#v:writeS" title="Data.Store">writeS</a></code>, <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code> has many similarities
with an <code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding" title="Data.Delta.Embedding">Embedding</a></code> of delta types. However, the main difference
is that manipulating a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> involves side effects.</p></div><a href="#g:6" id="g:6"><h3>Laws: Query</h3></a><div class="doc"><p>In order to query parts of the store content
without loading all of it into memory,
<code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> supports the operation</p><ul><li><code><a href="Data-Store.html#v:queryS" title="Data.Store">queryS</a></code> &#8212; run a specialized <code><a href="Data-Store.html#t:Query" title="Data.Store">Query</a></code> on the value contained in the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>.</li></ul><p>This operation is characterized by the following law:</p><ul><li><p>Querying a store <strong>commutes with <code><a href="Data-Store.html#v:query" title="Data.Store">query</a></code></strong>:</p><pre> &#8704;q. query q &lt;$&gt; (loadS s &gt;&gt;= either throw pure)  =  queryS s q</pre></li></ul></div><a href="#g:7" id="g:7"><h3>Monad</h3></a><div class="doc"><p>The monad <code>m</code> in <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code><code> m da</code> provides the storage space for the value.
Put differently, we like to think of <code>m</code> as a
<code><a href="https://hackage.haskell.org/package/transformers-0.6.1.1/docs/Control-Monad-Trans-State.html#v:State" title="Control.Monad.Trans.State">State</a></code> monad whose state contains the value.
However, this monad <code>m</code> could have <strong>additional side effects</strong>
such as exceptions, concurrency, non-determinism, and so on.
We would have to specify how a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> should behave with regards to these
effects, which complicates matters significantly.
(In fact, the equality sign <code>=</code> for the laws above has to be
interpreted &quot;&#8230; equal effects as far as the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> is concerned&quot;.
A proper approach to a specification would involve Hoare logic.)</p><p>For simplicity, we now assume that the monad <code>m</code> only has
the effects <strong>state</strong> and <strong>exceptions</strong> &#8212;
we make no attempt at specifying how an implementation
should behave for concurrent usage of, say, <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code>.
This assumption ensures some composability of the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> abstraction.
However, it also implies that choosing <code>m ~ </code><code><a href="https://hackage.haskell.org/package/stm-2.5.3.1/docs/Control-Monad-STM.html#v:STM" title="Control.Monad.STM">STM</a></code>
results in specified semantics, whereas choosing <code>m ~ </code><code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a></code> can
result in unspecified behavior.
(TODO: Perhaps create a type class <code>MonadSequential</code> to keep track
of this on the type level?)</p><p>More specifically, the interaction between <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> functions and
effects are as follows:</p><ul><li><p><strong>State</strong>: The laws presented above specify the essentials
of how the store state changes. However, this specification is not complete,
other &quot;expected&quot; rules such as</p><pre>writeS s a &gt;&gt; writeS s b  =  writeS s b</pre><p>etc. should also hold.</p></li><li><p><strong>Exceptions</strong>:</p><ul><li><code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> should not throw a synchronous exception,
  but return <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> instead.</li><li><code><a href="Data-Store.html#v:queryS" title="Data.Store">queryS</a></code> should throw a synchronous exception iff <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> returns <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code>.
  Moving the error case into the monad <code>m</code> simplifes the use of this operation.</li><li><code><a href="Data-Store.html#v:writeS" title="Data.Store">writeS</a></code> and <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> should not throw synchronous exceptions.
  However, in case they do throw an exception,
  the contents of the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> should be treated as corrupted,
  and <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> should return <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> subsequently.</li></ul></li><li><p><strong>Concurrency</strong>: We do not specify behavior under concurrent operation.
    Concurrent access to a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> is a frequent desideratum
    &#8212; but you will have to implement it yourself.</p><p>One design pattern is to use a custom monad <code>m ~ MyMonad</code>
that has a way of executing state changes atomically,</p><pre>atomically :: MyMonad a -&gt; IO a</pre><p>Specifically, <code>atomically</code> either applies <em>all</em> state changes,
or <em>none</em> of the state changes.
For instance, SQL transactions can be used for this,
see e.g. <a href="https://www.sqlite.org/lang_transaction.html">https://www.sqlite.org/lang_transaction.html</a>.
Then, you can implement a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code><code> MyMonad</code> by composing smaller <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>,
and use <code>atomically</code> in a scope where you want to use the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>
rather than implement it.</p><p>Use <code><a href="Data-Store.html#v:hoistStore" title="Data.Store">hoistStore</a></code><code> atomically</code> to map a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code><code> MyMonad</code>
to a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code><code> IO</code> where the monad has less atomicity.</p></li><li><strong>Non-determinism</strong> or other effects: Here be dragons.</li></ul></div><a href="#g:8" id="g:8"><h3>updateS, Maybe argument</h3></a><div class="doc"><p>The function <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code> applies a delta to the content of the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>.
Depending on the implementation of the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>, this operation may
require large parts of the content to be loaded into memory,
which is expensive.
In some use cases such as <code><a href="Data-DBVar.html#v:DBVar" title="Data.DBVar">DBVar</a></code>, the value is already available
in memory and can be used for executing the update.
For these cases, the <strong>first argument</strong> of <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code>
<strong>may</strong> provide the <strong>in-memory value</strong>.
We expect that the following property holds:</p><pre>  updateS s Nothing da
=
  loadS s &gt;&gt;= \(Right a) -&gt; updateS s (Just a) da</pre><p>The helper <code><a href="Data-Store.html#v:loadWhenNothing" title="Data.Store">loadWhenNothing</a></code> is useful for handling this argument.</p></div><a href="#g:9" id="g:9"><h3>loadS, SomeException</h3></a><div class="doc"><p>In the <strong>error case</strong> that the store does not contain a value,
<code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> returns a <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> value of type <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a></code>.
This type is a disjoint sum of all possible
error types (that is, members of the <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:Exception" title="Control.Exception">Exception</a></code> class).</p><p>We could parametrize <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> by an additional type parameter <code>e</code> representing
the possible error cases. However, we have opted to explore
a region of the design space where the number of type parameters
is kept to a minimum.</p><p>In fact, I would argue that making errors visible on the type level is not
very useful: we add much noise to the type level,
but we gain little type-safety in exchange.
Specifically, if we encounter an element of the <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a></code> type that
we did not expect, we can always <code>throw</code> it.
For example, consider the following code:</p><pre>let ea :: Either SomeException ()
    ea = [..]
in
    case ea of
        Right _ -&gt; &quot;everything is ok&quot;
        Left e -&gt; case fromException e of
            Just (AssertionFailed _) -&gt; &quot;bad things happened&quot;
            Nothing -&gt; throw e
</pre><p>In this example, using the more specific type <code>ea :: Either AssertionFailed ()</code>
would have eliminated the <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> case.
However, this case has the sensible default value:
<code>throw e</code>, we rethrow the exception that we did not expect.
Ruling out this case on the type-level adds almost no value.</p></div><a href="#g:10" id="g:10"><h1>Store, functions</h1></a><a href="#g:11" id="g:11"><h2>Query</h2></a><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:Query" class="def">Query</a> (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <span class="keyword">where</span> <a href="src/Data.Store.html#Query" class="link">Source</a> <a href="#t:Query" class="selflink">#</a></p><div class="doc"><p>A <strong>query</strong> <code>qa b</code> for the type <code>a ~ World qa</code>
 corresponds to a function <code>a -&gt; b</code>.
 Put differently, a query allows us to extract some information of type <code>b</code>
 from the larger type <code>a</code>.</p><p>Typically, instances of <code><a href="Data-Store.html#t:Query" title="Data.Store">Query</a></code> are
 generalized algebraic data types (GADT).</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a id="t:World" class="def">World</a> (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) <a href="src/Data.Store.html#World" class="link">Source</a> <a href="#t:World" class="selflink">#</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:query" class="def">query</a> :: qa b -&gt; <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa -&gt; b <a href="src/Data.Store.html#query" class="link">Source</a> <a href="#v:query" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Query">Instances</h4><details id="i:Query" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Query:Query:1"></span> <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a)</span> <a href="src/Data.Store.html#line-489" class="link">Source</a> <a href="#t:Query" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Query:Query:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:if:D:R:WorldWhole:World:1"></span> <span class="keyword">type</span> <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:if:D:R:WorldWhole:World:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="src"><span class="keyword">type</span> <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) = a</div></details></td></tr></table></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:query">query</a> :: <a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a b -&gt; <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) -&gt; b <a href="src/Data.Store.html#query" class="link">Source</a> <a href="#v:query" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Whole" class="def">Whole</a> a b <span class="keyword">where</span> <a href="src/Data.Store.html#Whole" class="link">Source</a> <a href="#t:Whole" class="selflink">#</a></p><div class="doc"><p>The query that retrieves the whole value.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Whole" class="def">Whole</a> :: <span class="keyword">forall</span> a. <a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Whole">Instances</h4><details id="i:Whole" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Whole:Query:1"></span> <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a)</span> <a href="src/Data.Store.html#line-489" class="link">Source</a> <a href="#t:Whole" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Whole:Query:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:if:D:R:WorldWhole:World:1"></span> <span class="keyword">type</span> <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:if:D:R:WorldWhole:World:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="src"><span class="keyword">type</span> <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) = a</div></details></td></tr></table></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:query">query</a> :: <a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a b -&gt; <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) -&gt; b <a href="src/Data.Store.html#query" class="link">Source</a> <a href="#v:query" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Whole:World:2"></span> <span class="keyword">type</span> <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a)</span> <a href="src/Data.Store.html#line-490" class="link">Source</a> <a href="#t:Whole" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Whole:World:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="src"><span class="keyword">type</span> <a href="Data-Store.html#t:World" title="Data.Store">World</a> (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) = a</div></details></td></tr></table></details></div></div><a href="#g:12" id="g:12"><h2>Constructors</h2></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SimpleStore" class="def">SimpleStore</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a = <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> a) (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Replace" title="Data.Delta.Core">Replace</a> a) <a href="src/Data.Store.html#SimpleStore" class="link">Source</a> <a href="#t:SimpleStore" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> which supports <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> and <code><a href="Data-Store.html#v:writeS" title="Data.Store">writeS</a></code>,
 but no fancy query or update operations.</p></div></div><div class="top"><p class="src"><a id="v:mkSimpleStore" class="def">mkSimpleStore</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m) =&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> a) -&gt; (a -&gt; m ()) -&gt; <a href="Data-Store.html#t:SimpleStore" title="Data.Store">SimpleStore</a> m a <a href="src/Data.Store.html#mkSimpleStore" class="link">Source</a> <a href="#v:mkSimpleStore" class="selflink">#</a></p><div class="doc"><p><code>mkSimpleStore loadS writeS</code> constructs a <code><a href="Data-Store.html#t:SimpleStore" title="Data.Store">SimpleStore</a></code>
 from the given operations.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:UpdateStore" class="def">UpdateStore</a> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da = <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m (<a href="Data-Store.html#t:Whole" title="Data.Store">Whole</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da)) da <a href="src/Data.Store.html#UpdateStore" class="link">Source</a> <a href="#t:UpdateStore" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> whose focus lies on updating the value rather than querying it.</p></div></div><div class="top"><p class="src"><a id="v:mkUpdateStore" class="def">mkUpdateStore</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, a <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da) =&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> a) -&gt; (a -&gt; m ()) -&gt; (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a -&gt; da -&gt; m ()) -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da <a href="src/Data.Store.html#mkUpdateStore" class="link">Source</a> <a href="#v:mkUpdateStore" class="selflink">#</a></p><div class="doc"><p><code>mkUpdateStore loadS writeS updateS</code> constructs an <code><a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a></code>
 from the given operations.</p></div></div><div class="top"><p class="src"><a id="v:mkQueryStore" class="def">mkQueryStore</a> :: <span class="keyword">forall</span> m qa da. (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da, <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> qa, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa) =&gt; (<span class="keyword">forall</span> b. qa b -&gt; m b) -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da <a href="src/Data.Store.html#mkQueryStore" class="link">Source</a> <a href="#v:mkQueryStore" class="selflink">#</a></p><div class="doc"><p><code>mkQueryStore queryS store</code> constructs a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>
 from a query and an <code><a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a></code>.</p></div></div><a href="#g:13" id="g:13"><h2>Combinators</h2></a><div class="top"><p class="src"><a id="v:hoistStore" class="def">hoistStore</a> :: <span class="keyword">forall</span> m n (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (<span class="keyword">forall</span> a. m a -&gt; n a) -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> n qa da <a href="src/Data.Store.html#hoistStore" class="link">Source</a> <a href="#v:hoistStore" class="selflink">#</a></p><div class="doc"><p>Lift</p></div></div><div class="top"><p class="src"><a id="v:embedStore" class="def">embedStore</a> :: (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadSTM-Internal.html#t:MonadSTM" title="Control.Monad.Class.MonadSTM.Internal">MonadSTM</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadMask" title="Control.Monad.Class.MonadThrow">MonadMask</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da) =&gt; <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding" title="Data.Delta.Embedding">Embedding</a> da db -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m db -&gt; m (<a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da) <a href="src/Data.Store.html#embedStore" class="link">Source</a> <a href="#v:embedStore" class="selflink">#</a></p><div class="doc"><p>Store one type in the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> of another type by using an <code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding" title="Data.Delta.Embedding">Embedding</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:pairStores" class="def">pairStores</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da (qb :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) db. <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qb db -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m (qa <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/GHC-Generics.html#t::-43-:" title="GHC.Generics">:+:</a> qb) (da, db) <a href="src/Data.Store.html#pairStores" class="link">Source</a> <a href="#v:pairStores" class="selflink">#</a></p><div class="doc"><p>Combine two <code>Stores</code> into a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> for pairs.</p><p>TODO: Handle the case where <code><a href="Data-Store.html#v:writeS" title="Data.Store">writeS</a></code> or <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code> throw an exception
 and partially break the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:newCachedStore" class="def">newCachedStore</a> :: <span class="keyword">forall</span> m (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da. (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadSTM-Internal.html#t:MonadSTM" title="Control.Monad.Class.MonadSTM.Internal">MonadSTM</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadEvaluate" title="Control.Monad.Class.MonadThrow">MonadEvaluate</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da, <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> qa, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa) =&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; m (<a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da) <a href="src/Data.Store.html#newCachedStore" class="link">Source</a> <a href="#v:newCachedStore" class="selflink">#</a></p><div class="doc"><p>Add a caching layer to a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code>.</p><p>Access to the underlying <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> is enforced to be sequential,
 but the cache can be accessed in parallel.</p><p>FIXME: There is still a small race condition where the cache
 could be written twice before it is filled. &#129300;
 TODO: Think about whether it is really necessary to handle concurrency here.
 I think the answer is &quot;yes&quot;, but only because the mutable variables
 provided by the monad <code>m</code> do not work together with e.g. SQL transactions.</p></div></div><a href="#g:14" id="g:14"><h2>Helpers</h2></a><div class="top"><p class="src"><a id="v:updateLoad" class="def">updateLoad</a> <a href="src/Data.Store.html#updateLoad" class="link">Source</a> <a href="#v:updateLoad" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:Exception" title="Control.Exception">Exception</a> e, <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; m (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> e t)</td><td class="doc"><p>How to load the value.</p></td></tr><tr><td class="src">-&gt; (e -&gt; m b)</td><td class="doc"><p>What to do with the error when loading the value.</p></td></tr><tr><td class="src">-&gt; (t -&gt; da -&gt; m b)</td><td class="doc"><p>What to do with the value.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> t</td><td class="doc"><p>Value, maybe loaded, maybe not.</p></td></tr><tr><td class="src">-&gt; da</td><td class="doc"><p>Delta.</p></td></tr><tr><td class="src">-&gt; m b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Helper for implementing <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code>
 for the case where a value is not yet loaded.</p></div></div><div class="top"><p class="src"><a id="v:loadWhenNothing" class="def">loadWhenNothing</a> :: <span class="keyword">forall</span> m da (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da) =&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da) -&gt; <a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da -&gt; m (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da) <a href="src/Data.Store.html#loadWhenNothing" class="link">Source</a> <a href="#v:loadWhenNothing" class="selflink">#</a></p><div class="doc"><p>Helper for implementing <code><a href="Data-Store.html#v:updateS" title="Data.Store">updateS</a></code>.
 Call <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> from a <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> if the value is not already given in memory.</p></div></div><a href="#g:15" id="g:15"><h2>Testing</h2></a><div class="top"><p class="src"><a id="v:embedStore-39-" class="def">embedStore'</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) da db. (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m) =&gt; <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding-39-" title="Data.Delta.Embedding">Embedding'</a> da db -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m db -&gt; <a href="Data-Store.html#t:UpdateStore" title="Data.Store">UpdateStore</a> m da <a href="src/Data.Store.html#embedStore%27" class="link">Source</a> <a href="#v:embedStore-39-" class="selflink">#</a></p><div class="doc"><p>Store one type in the <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> of another type by using an <code><a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Embedding.html#t:Embedding" title="Data.Delta.Embedding">Embedding</a></code>.</p><p>Note: This function is exported for testing and documentation only,
 use the more efficient <code><a href="Data-Store.html#v:embedStore" title="Data.Store">embedStore</a></code> instead.</p></div></div><div class="top"><p class="src"><a id="v:newStore" class="def">newStore</a> :: <span class="keyword">forall</span> m da (qa :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadSTM-Internal.html#t:MonadSTM" title="Control.Monad.Class.MonadSTM.Internal">MonadSTM</a> m, <a href="https://hackage.haskell.org/package/io-classes-1.7.0.0/docs/Control-Monad-Class-MonadThrow.html#t:MonadThrow" title="Control.Monad.Class.MonadThrow">MonadThrow</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> da, <a href="Data-Store.html#t:Query" title="Data.Store">Query</a> qa, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> da <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Type-Equality.html#t:-126-" title="Data.Type.Equality">~</a> <a href="Data-Store.html#t:World" title="Data.Store">World</a> qa) =&gt; m (<a href="Data-Store.html#t:Store" title="Data.Store">Store</a> m qa da) <a href="src/Data.Store.html#newStore" class="link">Source</a> <a href="#v:newStore" class="selflink">#</a></p><div class="doc"><p>An in-memory <code><a href="Data-Store.html#t:Store" title="Data.Store">Store</a></code> from a mutable variable (<code>TVar</code>).
 Useful for testing.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:NotInitialized" class="def">NotInitialized</a> <a href="src/Data.Store.html#NotInitialized" class="link">Source</a> <a href="#t:NotInitialized" class="selflink">#</a></p><div class="doc"><p>Failure that occurs when calling <code><a href="Data-Store.html#v:loadS" title="Data.Store">loadS</a></code> on a <code><a href="Data-Store.html#v:newStore" title="Data.Store">newStore</a></code> that is empty.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:NotInitialized" class="def">NotInitialized</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:NotInitialized">Instances</h4><details id="i:NotInitialized" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:NotInitialized:Exception:1"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:Exception" title="Control.Exception">Exception</a> <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a></span> <a href="src/Data.Store.html#line-424" class="link">Source</a> <a href="#t:NotInitialized" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:NotInitialized:Exception:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toException">toException</a> :: <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> <a href="#v:toException" class="selflink">#</a></p><p class="src"><a href="#v:fromException">fromException</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Exception.html#t:SomeException" title="Control.Exception">SomeException</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> <a href="#v:fromException" class="selflink">#</a></p><p class="src"><a href="#v:displayException">displayException</a> :: <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:displayException" class="selflink">#</a></p><p class="src"><a href="#v:backtraceDesired">backtraceDesired</a> :: <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:backtraceDesired" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:NotInitialized:Show:2"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a></span> <a href="src/Data.Store.html#line-423" class="link">Source</a> <a href="#t:NotInitialized" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:NotInitialized:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:NotInitialized:Eq:3"></span> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a></span> <a href="src/Data.Store.html#line-423" class="link">Source</a> <a href="#t:NotInitialized" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:NotInitialized:Eq:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Data-Store.html">Data.Store</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="Data-Store.html#t:NotInitialized" title="Data.Store">NotInitialized</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:updateSequence" class="def">updateSequence</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Delta" title="Data.Delta.Core">Delta</a> delta) =&gt; (<a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> delta -&gt; delta -&gt; m ()) -&gt; <a href="https://hackage.haskell.org/package/delta-types-1.0.0.0/docs/Data-Delta-Core.html#t:Base" title="Data.Delta.Core">Base</a> delta -&gt; [delta] -&gt; m () <a href="src/Data.Store.html#updateSequence" class="link">Source</a> <a href="#v:updateSequence" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>